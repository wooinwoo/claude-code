export class Poller {
  constructor() {
    this.cache = new Map();
    this.sseClients = new Set();
    this.intervalMap = new Map();
    this.errorCounts = new Map();
    this._speedMultiplier = 1; // 1 = normal, >1 = slower (adaptive)
  }

  register(name, fetchFn, interval, eventName) {
    if (this.intervalMap.has(name)) {
      clearInterval(this.intervalMap.get(name));
    }

    const poll = async () => {
      try {
        const data = await fetchFn();
        const prev = this.cache.get(name);
        const dataStr = JSON.stringify(data);

        // Reset error count on success
        this.errorCounts.set(name, 0);

        if (!prev || prev.raw !== dataStr) {
          this.cache.set(name, { data, raw: dataStr, timestamp: Date.now(), ttl: interval * 2 });
          this.broadcast(eventName, data);
        }
      } catch (err) {
        const count = (this.errorCounts.get(name) || 0) + 1;
        this.errorCounts.set(name, count);
        if (count <= 3) {
          console.error(`[Poller] ${name}: ${err.message} (${count}/3)`);
        } else if (count === 4) {
          console.error(`[Poller] ${name}: suppressing further errors`);
        }
      }
    };

    poll();
    const adaptiveInterval = () => Math.round(interval * this._speedMultiplier);
    // Use dynamic interval via recursive setTimeout instead of fixed setInterval
    const scheduleNext = () => {
      const timerId = setTimeout(async () => {
        await poll();
        this.intervalMap.set(name, scheduleNext());
      }, adaptiveInterval());
      return timerId;
    };
    this.intervalMap.set(name, scheduleNext());
  }

  // Adaptive speed control â€” call from server when visibility changes
  setSpeed(multiplier) {
    this._speedMultiplier = Math.max(1, Math.min(multiplier, 10));
  }

  unregister(name) {
    if (this.intervalMap.has(name)) {
      clearTimeout(this.intervalMap.get(name));
      this.intervalMap.delete(name);
    }
    this.cache.delete(name);
    this.errorCounts.delete(name);
  }

  broadcast(event, data) {
    const msg = `event: ${event}\ndata: ${JSON.stringify(data)}\n\n`;
    for (const res of this.sseClients) {
      try {
        res.write(msg);
      } catch {
        this.sseClients.delete(res);
      }
    }
  }

  getCached(name) {
    const entry = this.cache.get(name);
    if (!entry) return null;
    return entry.data;
  }

  getAllCached(prefix) {
    const result = {};
    for (const [key, entry] of this.cache) {
      if (key.startsWith(prefix)) {
        result[key.replace(prefix, '')] = entry.data;
      }
    }
    return result;
  }

  addClient(res) {
    this.sseClients.add(res);
  }

  removeClient(res) {
    this.sseClients.delete(res);
  }

  stop() {
    for (const id of this.intervalMap.values()) clearTimeout(id);
    this.intervalMap.clear();
  }
}
